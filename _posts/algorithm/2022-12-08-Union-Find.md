---
layout: post
title: "[Algorithm] 유니온 파인드(Union Find)"
subtitle: "유니온 파인드는 일반적으로 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 union / 두 노드가 같은 집합에 속해 있는지를 확인하는 find연산으로 구성"
categories : Algorithm
tags : [Algorithm]
date: 2022-12-08 00:00:00 +0900
---

> 유니온 파인드는 일반적으로 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 union 연산  
> 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성되어 있는 알고리즘이다.


<br>

## 유니온 파인드 이론

`union, find연산`

- union 연산: 각 노드가 속한 집합을 1개로 합치는 연산이다. 노드 a, b가 a ∈ A, b ∈ B일 때 union(a, b) 는 A ∪ B를 말한다.
- find 연산: 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산이다. 노드 a가 a ∈ A일 때 find(a)는 A 집합의 대표 노드를 반환한다.

<br>

### 유니온 파인드 구현 방법

1. 유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것이다.
   **처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 된다.
   각 노드가 모두 대표 노드이므로 배열은 자신의 인덱스값으로 초기화한다.**
   ![img.png](https://user-images.githubusercontent.com/74996516/206206686-e0487718-752a-4e84-8368-b60cb4709715.png)

2. 2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 **union 연산을 수행한다.**
   배열을 보면 1,4와 5,6을 union 연산으로 연결한다. 배열 [4]는 1로, 배열[6]은 5로 업데이트한다.
   union(4, 6)으로 4와 6을 연결한다. 그런데 4, 6은 대표 노드(**자기 자신**)가 아니다.
   그래서 각 노드의 대표노드를 찾아 올라간 다음 그 대표 노드를 연결한다. 지금의 경우 4의 대표 노드 1에 6의 대표 노드 5를 연결한 것이다.
   배열은 `[1, 2, 3, 1, 1, 5]`가 된다.
   ![img_1.png](https://user-images.githubusercontent.com/74996516/206206691-88372561-8df6-47a4-8910-7b5ae5542c20.png)

3. find 연산은 자신의 속한 집합의 대표 노드를 찾는 연산이다.
   find 연산은 단순히 대표 노드를 찾는 역할만 하는 것이 아니라 그래프를 정돈하고 시간 복잡도를 향상시킨다.
   > find 연산의 작동 원리
   >
   > ① 대상 노드 배열에 index 값과 value 값이 동일한지 확인한다. (처음 각 노드가 모두 대표노드로 자신의 인덱스 값으로 초기화 하였다.)  
   > ② 동일하지 않으면 value값이 가리키는 index 위치로 이동한다.  
   > ③ 이동 위치의 index값과 value 값이 같을 때까지 **①~②를 반복한다.**  
   > ④ 대표 노드에 도달하면 재귀 함수를 빠져나면서 거치는 모든 노드값을 루트 노드값을 변경한다.

   ![img_2.png](https://user-images.githubusercontent.com/74996516/206206700-f912da5c-2ee9-4648-ab7e-e5b77d008ed7.png)

---

#### find 연산의 효과

`find 연산은 시간 복잡도가 줄어드는 효과를 얻게 된다. 연산을 할 때 거치는 노드들이 대표 노드와 바로 연결되는 형태로 변경되는 것을 알 수 있다. 이렇게 되면 추후 노드와 관련된 find 연산 속도가 O(1)로 변경된다.`

![img_3.png](https://user-images.githubusercontent.com/74996516/206206707-28693bde-67a0-43d1-b2fb-d666ec78adb6.png)

즉, 한 번의 find 연산을 이용해 모든 노드가 루트 노드에 직접 연결되는 형태로 변경되는 것을 볼 수 있다. 

이러한 형태로 변경되면 이후 find 연산이 진행될 때 경로 압축의 효과가 나타난다.

예를 들어 이후 find(4) 연산을 수행하면 한 번의 이동으로 바로 대표 노드를 찾을 수 있다.



### 관련된 문제 

- [거짓말](https://www.acmicpc.net/problem/1043)
- [집합의 표현](https://www.acmicpc.net/problem/1717)
- [여행 가자](https://www.acmicpc.net/problem/1976)
